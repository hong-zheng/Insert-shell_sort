#define _CRT_SRCURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void Print(int arr[], int length){
	for (int i = 0; i<length; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

// 二分查找，有序数组，通过二分的方式来找到数据
//{1,2,3,45,66,75,77,77,88,98,111,123,344}
void binnary_find(int* arr,int len,int key){
	int left = 0;
	int right = len - 1;
	int mid = 0;
	while (left<=right){
		mid = left + (right - left) / 2;
		if (arr[mid] == key){
			printf("%d\n", arr[mid]);
			break;
		}else if (arr[mid] > key){
			right = mid;
		}else{
			left = mid;
		}
	}
}
// 插入排序
void insert_sort(int* arr,int length){
	for (int i = 1; i < length;i++){
		if (arr[i] < arr[i-1]){
			int j = 0;
			int tmp = arr[i];
			for (j = i - 1; j >= 0 && tmp < arr[j];j--){
				arr[j + 1] = arr[j];
			}
			arr[j + 1] = tmp;
		}
	}
}
// 希尔排序
void shellSort(int* arr,int length){
	int step = length / 2;
	while (step>=1){
		for (int k = step; k < length;k++){
			for (int i = 1; i < length;i++){
				if (arr[i] < arr[i-1]){
					int j = 0;
					int tmp = arr[i];
					for (j = i-step; j >= 0 && arr[j] > tmp; j -= step){
						arr[j + step] = arr[j];
					}
					arr[j + step] = tmp;
				}
			}
		}
		step /= 2;
	}
}
// radix
#define MAX 2422
void radixSort(int* arr,int length){
	int tmp[MAX + 1];
	memset(tmp,0,sizeof(int)*(MAX+1));
	for (int i = 0; i < length;i++){
		tmp[arr[i]]++;
	}
	for (int i = 0; i < MAX + 1;i++){
		while (tmp[i]--){
			printf("%d ",i);
		}
	}
	printf("\n");
}
// bucket
#define LENGTH 11
void bucket_sort(int* arr,int length){
	for (int i = 1; i < MAX;i*=10){
		int tmp[10][LENGTH];
		memset(tmp, -1, sizeof(int) * 10 * LENGTH);
		for (int j = 0; j < length;j++){
			int m = arr[j] / i % 10;
			tmp[m][j] = arr[j];
		}
		int  k = 0;
		for (int i = 0; i < length;i++){
			for (int j = 0; j < length;j++){
				if (-1 != tmp[i][j]){
					arr[k++] = tmp[i][j];
				}
			}
		}
	}
}
// bubble
void bubble_sort(int arr[],int length){
	for (int i = 0; i < length-1;i++){
		for (int j = 0; j < length - i - 1;j++){
			if (arr[j+1] < arr[j]){
				int tmp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = tmp;
			}
		}
	}
}
// 归并排序
// 先合并
void merge_sort(int arr[],int l,int m,int r){
	int len = r - l + 1;
	int left = l;
	int right = m + 1;
	int* newArr = (int*)malloc(sizeof(int)*len);
	int k = 0;
	while (left <= m && right<= r){
		if (arr[left] < arr[right]){
			newArr[k++] = arr[left++];
		}
		else{
			newArr[k++] = arr[right++];
		}
	}
	while (left <= m){
		newArr[k++] = arr[left++];
	}
	while (right<=r){
		newArr[k++] = arr[right++];
	}
	memcpy(arr+l,newArr,sizeof(int)*len);
	free(newArr);
	newArr = NULL;
}
// 分组
void chaifen(int* arr,int l,int r){
	if (l == r){
		return;
	}
	int m = l + (r - l) / 2;
	chaifen(arr, l, m);
	chaifen(arr, m+1, r);
	merge_sort(arr,l,m,r);
}
void MERGE(int* arr, int len){
	chaifen(arr,0,len-1);
}
int main(){
	int arr[] = {1,2,3,45,66,75,77,78,79,88,98,111,123,344};
	int arr1[] = { 210, 110, 1, 22, 111, 214, 56, 1332, 152, 2422, 349 };
	int len1 = sizeof(arr1) / sizeof(arr1[0]);
	Print(arr1, len1);
	//MERGE(arr1, len1);
	Print(arr1, len1);
	//binnary_find(arr,sizeof(arr)/sizeof(arr[0]),88);
	system("pause");
	return 0;
}
//// 合并,将左右两边 都有序的数组合并为一个全局有序的数组
//void mergeSort(int* arr, int l, int m, int r){
//	int len = r - l + 1;
//	int* newArr = (int*)malloc(len*sizeof(int));
//	int left = l;
//	int right = m + 1;
//	int k = 0;
//	while (left <= m && right <= r){
//		if (arr[left] < arr[right]){
//			newArr[k++] = arr[left++];
//		}
//		else{
//			newArr[k++] = arr[right++];
//		}
//	}
//	while (left <= m){
//		newArr[k++] = arr[left++];
//	}
//	while (right <= r){
//		newArr[k++] = arr[right++];
//	}
//	memcpy(arr + l, newArr, sizeof(int)*len);
//	free(newArr);
//	newArr = NULL;
//}
////拆分，将一个整数组拆分为两个数组，递归拆分
//void chaifen(int* arr, int l, int r){
//	if (l == r){
//		return;
//	}
//	int m = l + (r - l) / 2;
//	chaifen(arr, l, m);
//	chaifen(arr, m + 1, r);
//	mergeSort(arr, l, m, r);
//}
//void MERGESORT(int* arr, int length){
//	chaifen(arr, 0, length - 1);
//}
//int main(){
//	int nums2[] = { 1, 2, 4, 5, 6, 7 };
//	//int num2 = 6;
//	//int nums1[] = { 1,1,2,3,0,0,0,0,0,0};
//	//int num1 = 4;
//	////merge(nums1, sizeof(nums1) / sizeof(nums1[0]), num1, nums2, sizeof(nums1) / sizeof(nums1[0]), num2);
//	//Print(nums1, sizeof(nums1) / sizeof(nums1[0]));
//
//	int arr[] = { 210, 110, 1, 22, 111, 214, 56, 1332, 152, 2422, 349 };
//	int length = sizeof(arr) / sizeof(arr[0]);
//	Print(arr, length);
//	MERGESORT(arr, length);
//	//MERGRSORT(arr,length);
//	Print(arr, length);
//	//int sum = 100133;
//	//int count = 0;
//	//for (int i = 1; i<=sum; i *= 10){
//	//	count++;
//	//}
//	//printf("%d ",count);
//	system("pause");
//	return 0;
//}


////#define _CRT_SRCURE_NO_WARNINGS 1
////#include<stdio.h>
////#include<stdlib.h>
////#include<string.h>
////void Print(int arr[], int length){
////	for (int i = 0; i < length; i++){
////		printf("%d ", arr[i]);
////	}
////	printf("\n");
////}
////// 合并,将左右两边 都有序的数组合并为一个全局有序的数组
////void mergeSort(int* arr,int l,int m,int r){
////	int len = r - l + 1;
////	int* newArr = (int*)malloc(len*sizeof(int));
////	int left = l;
////	int right = m + 1;
////	int k = 0;
////	while (left <= m && right<=r){
////		if (arr[left] < arr[right]){
////			newArr[k++] = arr[left++];
////		}
////		else{
////			newArr[k++] = arr[right++];
////		}
////	}
////	while (left <= m){
////		newArr[k++] = arr[left++];
////	}
////	while (right<=r){
////		newArr[k++] = arr[right++];
////	}
////	memcpy(arr+l,newArr,sizeof(int)*len);
////	free(newArr);
////	newArr = NULL;
////}
//////拆分，将一个整数组拆分为两个数组，递归拆分
////void chaifen(int* arr,int l,int r){
////	if (l == r){
////		return;
////	}
////	int m = l + (r - l) / 2;
////	chaifen(arr, l, m);
////	chaifen(arr, m+1, r);
////	mergeSort(arr,l,m,r);
////}
////void MERGESORT(int* arr, int length){
////	chaifen(arr, 0, length - 1);
////}
////int main(){
////	int nums2[] = { 1,2,4,5,6,7};
////	//int num2 = 6;
////	//int nums1[] = { 1,1,2,3,0,0,0,0,0,0};
////	//int num1 = 4;
////	////merge(nums1, sizeof(nums1) / sizeof(nums1[0]), num1, nums2, sizeof(nums1) / sizeof(nums1[0]), num2);
////	//Print(nums1, sizeof(nums1) / sizeof(nums1[0]));
////
////	int arr[] = { 210, 110, 1,22, 111, 214, 56,1332, 152, 2422, 349 };
////	int length = sizeof(arr) / sizeof(arr[0]);
////	Print(arr, length);
////	MERGESORT(arr, length);
////	//MERGRSORT(arr,length);
////	Print(arr, length);
////	//int sum = 100133;
////	//int count = 0;
////	//for (int i = 1; i<=sum; i *= 10){
////	//	count++;
////	//}
////	//printf("%d ",count);
////	system("pause");
////	return 0;
////}
////
////// 归并排序首先是将数组分而治之
////// 合并两半有序数组,合并之后为有序的数组
//////// l       m         r
//////// 1 3 4 5 7 3 4 5 8 9
//////void mergeArr(int* arr, int l, int m, int r){
//////	int len = r - l + 1;
//////	// 该数组有序存放有序数组
//////	int* newArr = (int*)malloc(sizeof(int)*len);
//////	int left = l;
//////	int right = m + 1;
//////	int k = 0;// 记录新数组
//////	while (left <= m && right <= r){
//////		if (arr[left] < arr[right]){
//////			newArr[k++] = arr[left++];
//////		}
//////		else{
//////			newArr[k++] = arr[right++];
//////		}
//////	}
//////	while (right <= r){
//////		newArr[k++] = arr[right++];
//////	}
//////	while (left <= m){
//////		newArr[k++] = arr[left++];
//////	}
//////	memcpy(arr + l, newArr, sizeof(int)*len);
//////	free(newArr);
//////	newArr = NULL;
//////}
////////拆分数组
//////void chaifen(int* arr, int l, int r){
//////	if (l == r){
//////		return;
//////	}
//////	int m = l + (r - l) / 2;
//////	chaifen(arr, l, m);
//////	chaifen(arr, m + 1, r);
//////	mergeArr(arr, l, m, r);
//////}
//////void mergeSort(int* arr, int length){
//////	chaifen(arr, 0, length - 1);
//////}
//////// l       m         r
//////// 1 3 5 7 9 0 2 5 7 8 
//////// 合并
//////void merge_sort(int* arr, int l, int m, int r){
//////	// 左边的一半 [l,m]
//////	// 右边的一半 [m+1,r]
//////	// 需要临时数组
//////	// r-l+1
//////	// left=l  right=m+1
//////	//比较left和right所在数据，谁小谁移动
//////	// 只有对有序数组才能合并
//////	// 对左右两边都是有序的数组
//////	// 1、准备临时数组
//////	int len = r - l + 1;
//////	int* pTemp = (int*)malloc(len*sizeof(int));
//////	int k = 0; //临时数组的下标
//////	int left = l; // 左边数组第一个元素下标
//////	int right = m + 1;// 右边数组第一个元素下标
//////	// 2、数据依序从原来数组中放入临时数组
//////	// 2.1循环放完一半
//////	while (left <= m && right <= r){
//////		if (arr[left] < arr[right]){
//////			pTemp[k++] = arr[left++];
//////		}
//////		else
//////		{
//////			pTemp[k++] = arr[right++];
//////		}
//////	}
//////	// 2.2
//////	while (right <= r){
//////		pTemp[k++] = arr[right++];
//////	}
//////	while (left <= m){
//////		pTemp[k++] = arr[left++];
//////	}
//////	// 3、数据从临时数组拷贝回原数组，释放临时数组
//////	memcpy(arr + l, pTemp, sizeof(int)*len);
//////	free(pTemp);
//////	pTemp = NULL;
//////
//////}
//////
////////把一个数组拆成两等份
//////void mergeSort(int* arr, int l, int r){
//////	if (l == r){
//////		return;
//////	}
//////	int m = l + (r - l) / 2;
//////	mergeSort(arr, l, m); // 拆左边
//////	mergeSort(arr, m + 1, r); // 拆右边
//////	merge_sort(arr, l, m, r); // 合并
//////}
//////void MERGRSORT(int* arr, int len){
//////	mergeSort(arr, 0, len - 1);
//////}
////// 拆半 分治
////// 二分查找 归并排序
////
////
////// 树：各种程序，底层,例如：文件系统（多分支树状结构）
////// 森林:多棵树
////// 树具备递归性 
////// 根：第一个结点 第一颗子树
////// 层 ：同层结点到根的距离相等
//////路径长度：找到某个结点经过几次寻址
////// 高度: 最远叶子结点的距离
////// N叉树
//////// 链表就是一个1叉树
//////void bucket_sort(int arr[], int length){
//////	for (int i = 1; i < MAXNUM; i *= 10){
//////		int tmp[10][NUM];
//////		memset(tmp, -1, sizeof(int) * 10 * NUM);
//////		// 根据元素情况入桶
//////		for (int j = 0; j < length; j++){
//////			int m = arr[j] / i % 10;
//////			tmp[m][j] = arr[j];
//////		}
//////		// 出桶
//////		int k = 0;
//////		for (int i = 0; i < 10; i++){
//////			for (int j = 0; j < NUM; j++){
//////				if (-1 != tmp[i][j]){
//////					arr[k++] = tmp[i][j];
//////				}
//////			}
//////		}
//////	}
//////}
//////void bubble_sort(int arr[], int length){
//////	for (int i = 0; i < length - 1; i++){
//////		for (int j = 0; j < length - i - 1; j++){
//////			if (arr[j + 1] < arr[j]){
//////				int tmp = arr[j];
//////				arr[j] = arr[j + 1];
//////				arr[j + 1] = tmp;
//////			}
//////		}
//////	}
//////}
////////[]
////////2
//////int removeElement(int* nums, int numsSize, int val){
//////	int k = 0;
//////	for (int i = 0; i<numsSize - k; i++){
//////		if (val == nums[i]){
//////			for (int j = i + 1; j<numsSize - k; j++){
//////				nums[j - 1] = nums[j];
//////			}
//////			i--;
//////			k++;
//////		}
//////	}
//////	return numsSize - k;
//////}
////////int nums1[] = { 1, 2, 3, 0, 0, 0 };
////////int num1 = 3;
////////int nums2[] = { 2, 5, 6 };
//////////int num2 = 3;
////////void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
////////	while (m>0 && n>0){
////////		if (nums1[m - 1] >= nums2[n - 1]){
////////			nums1[nums1Size - 1] = nums1[m - 1];
////////			nums1Size--;
////////			m--;
////////		}
////////		if (nums1[m - 1] < nums2[n - 1]){
////////			nums1[nums1Size - 1] = nums2[n - 1];
////////			nums1Size--;
////////			n--;
////////		}
////////	}
////////	if (n>0){
////////		// memcpy(nums1,nums2,sizeof(int)*nums1Size);
////////		for (int i = 0; i<nums1Size; i++){
////////			nums1[i] = nums2[i];
////////		}
////////	}
////////}
////////[2, 0]
////////1
////////[1]
////////1
//////void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
//////	int* newnums = (int*)malloc(sizeof(int)*(m + n));
//////	int i = 0;
//////	int j = 0;
//////	int k = 0;
//////	while (i<m && j<n){
//////		if (nums1[i] >= nums2[j]){
//////			newnums[k] = nums2[j];
//////			k++;
//////			j++;
//////		}
//////		if (nums1[i] < nums2[j]){
//////			newnums[k] = nums1[i];
//////			k++;
//////			i++;
//////		}
//////	}
//////	if (i<m){
//////		memcpy(newnums + k, nums1 + i, sizeof(int)*(m - i));
//////	}
//////	if (j<n){
//////		memcpy(newnums + k, nums2 + j, sizeof(int)*(n - j));
//////	}
//////	memcpy(nums1, newnums, sizeof(int)*(m + n));
//////	free(newnums);
//////}
//////void rotate(int* nums, int numsSize, int k){
//////	k = k%numsSize;
//////	for (int i = 0; i<k; i++){
//////		int bbjj = nums[numsSize - 1];
//////		for (int j = numsSize - 2; j >= 0; j--){
//////			nums[j + 1] = nums[j];
//////		}
//////		nums[0] = bbjj;
//////	}
//////}
//////}
////////    bubble
//////void insert_sort(int arr[], int length){
//////	for (int i = 1; i < length; i++){
//////		if (arr[i] < arr[i - 1]){
//////			int j = 0;
//////			int tmp = arr[i];
//////			for (j = i - 1; j >= 0 && arr[j] > tmp; j--){
//////				arr[j + 1] = arr[j];
//////			}
//////			arr[j + 1] = tmp;
//////		}
//////	}
//////}
//////void shell_sort(int arr[], int length){
//////	int step = length / 2;
//////	while (step >= 1){
//////		for (int k = step; k < length; k++){
//////			for (int i = 1; i < length; i++){
//////				if (arr[i] < arr[i - 1]){
//////					int j = 0;
//////					int tmp = arr[i];
//////					for (j = i - step; j >= 0 && arr[j] > tmp; j -= step){
//////						arr[j + step] = arr[j];
//////					}
//////					arr[j + step] = tmp;
//////				}
//////			}
//////		}
//////		step /= 2;
//////	}
//////}
//////#define MAX (623+1)
//////void radix_sort(int arr[], int length){
//////	int tmp[MAX] = { 0 };
//////	for (int i = 0; i < length; i++){
//////		tmp[arr[i]]++;
//////	}
//////	for (int i = 0; i < MAX; i++){
//////		while (tmp[i]--){
//////			printf("%d ", i);
//////		}
//////	}
//////}
//////#define MAXNUM 623
//////#define NUM 13